<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记录一下axios食用方法，以及工作中遇到的坑]]></title>
    <url>%2F2019%2F07%2F28%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Baxios%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[初上手axios真的被坑一脸血（摊上个不靠谱的同事有毒首先放一下axios的食用姿势 //这是get方法 axios.get(&apos;/user?ID=12345&apos;) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); //这是post方法 axios.post(&apos;/user&apos;, { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); //推荐统一用api方法 axios({ method: &apos;post&apos;, url: &apos;/user/12345&apos;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot; } data: { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; } }); 在使用GET方法传递参数时使用的是params，并且官方文档中介绍为：params are the URL parameters to be sent with the request. Must be a plain object or a URLSearchParams object。plain object（纯对象）是指用JSON形式定义的普通对象或者new Object()创建的简单对象；而URLSearchParams object指的是一个可以由URLSearchParams接口定义的一些实用方法来处理 URL 的查询字符串的对象，也就是说params传参是以/user?ID=1&amp;name=mike&amp;sex=male形式传递的(意思是get请求会以数据附加到URL地址后面的形式，一起传给后台而在使用POST时对应的传参使用的是data，data是作为请求体发送的，同样使用这种形式的还有PUT，PATCH等请求方式。也就是说使用的是序列化后的json格式字符串来传递参数，如：{ “name” : “mike”, “sex” : “male” }；同时，后台必须要以支持@RequestBody的形式接收参数，否则会出现前台传参正确，后台接收不到的情况。axios引入就不说了，这里在下项目用的是vue-axios重点说一下，axios有三种常见的数据请求格式Content-Type: application/json ： 请求体中的数据会以json字符串的形式发送到后端Content-Type: application/x-www-form-urlencoded：请求体中的数据会以普通表单形式（键值对）发送到后端Content-Type: multipart/form-data： 它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。axios默认的请求头是第一种：Content-Type: application/json，并且在axios中会默认把数据序列化成JSON字符串格式。对于第二种格式：application/x-www-form-urlencoded的传参用 URLSearchParams API传递参数let param = new URLSearchParams() param.append(&apos;username&apos;, &apos;admin&apos;) param.append(&apos;pwd&apos;, &apos;admin&apos;) axios({ method: &apos;post&apos;, url: &apos;/api, data: param }) 需要注意的是： URLSearchParams 不支持所有的浏览器，但是总体的支持情况还是 OK 的，所以优先推荐这种简单直接的解决方案修改axios默认的请求头axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 或者直接在api里更改 {headers:{&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;}} 之后引入qs库的Qs.stringify方法 import Qs from &apos;qs&apos; let data = { &quot;username&quot;: &quot;admin&quot;, &quot;pwd&quot;: &quot;admin&quot; } axios({ headers: { &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; }, method: &apos;post&apos;, url: &apos;/api/xxx&apos;, data: Qs.stringify(data) }) 修改axios源码中的transformRequestimport Qs from &apos;qs&apos; axios({ url: &apos;/api/lockServer/search&apos;, method: &apos;post&apos;, transformRequest: [function (data) { // 对 data 进行任意转换处理 return Qs.stringify(data) }], headers: { &apos;deviceCode&apos;: &apos;A95ZEF1-47B5-AC90BF3&apos; }, data: { username: &apos;admin&apos;, pwd: &apos;admin&apos; } }) 手动连结axios.post(&apos;/api/lockServer/search&apos;,&quot;userName=&apos;admin&apos;&amp;pwd=&apos;admin&apos;&quot;); 对于第三种格式：Content-Type: multipart/form-data的传参对于这种类型的数据，我们常见前端页面上传个人图像，然后点击保存发送后端修改原始数据。1234567891011121314151617let params = new FormData()params.append(&apos;file&apos;, this.file)params.append(&apos;id&apos;, localStorage.getItem(&apos;userID&apos;))params.append(&apos;userName&apos;, this.name)params.append(&apos;sex&apos;, this.sex)params.append(&apos;mobile&apos;, this.phone)params.append(&apos;email&apos;, this.email)params.append(&apos;qq&apos;, this.qq)params.append(&apos;weChat&apos;, this.WeChat)axios.post(URL, params, &#123;headers: &#123;&apos;Content-Type&apos;: &apos;multipart/form-data&apos;&#125;&#125;).then(res =&gt; &#123;if (res.data.code === 0) &#123;this.$router.go(-1)&#125;&#125;).catch(error =&gt; &#123;alert(&apos;更新用户数据失败&apos; + error)&#125;)后记，错误500多半是服务器问题，打印下自己的数据格式，看跟接口要求的格式是否一样，然后就是后端的锅了。错误403是服务器拒绝访问，叫后端开接口，检查下自己URL有没输错。错误404，请求内容不存在。错误408，请求超时。301，重定向。200，返回正确结果即成功。这里推荐模拟请求接口的软件postman，拿到接口先测一遍（便于甩锅另外，axios可以在全局配置请求头，请求格式，拦截器等，具体请参考官方文档，使用例子有登陆拦截配置token过期验证处理，把axios方法封装成自定义api……]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个十分简单的git教程网站]]></title>
    <url>%2F2019%2F06%2F03%2F%E4%B8%80%E4%B8%AA%E5%8D%81%E5%88%86%E7%AE%80%E5%8D%95%E7%9A%84git%E6%95%99%E7%A8%8B%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[分享链接:git - the simple guide支持中文，需翻墙]]></content>
  </entry>
  <entry>
    <title><![CDATA[记录一下vps的搭建过程]]></title>
    <url>%2F2019%2F06%2F02%2Fvps%2F</url>
    <content type="text"><![CDATA[首先，你得先有一台服务器例如抛瓦工、vultr之类的，自己去比较哪家性价比好点，想当梯子用的话必须买外国的服务器哦。怎么购买就不多说了，网上教程一大把，还支持支付宝/微信充值，这里仅记录一下成功搭建的过程。首先购买到服务器之后，在控制台找到你服务器的IP，先去找个海外网速测速网站测试一下：测速网站 这里勾去外网只选国内，可以看到服务器ip与大陆各地区之间的延迟（如果通通超时的话，就是ip被ban了）ip被ban的话只能更换ip了，xshell连不上服务器同理。服务器系统建议选centOS6 64或7 64，网上教程普遍为6，但cenntOS7好像也没问题。选好服务器之后，在你本地电脑里下一个xshell用来连接服务器新建主机名填服务器ip用户身份验证里，id普遍为root，密码填你服务器随机分配的密码登陆成功后，控制台提示如图五个流程搞定第一步yum -y install wget第二步安装中文版ssr1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh进去界面是中文的，非常简单！输入：1 安装ShadowsocksR，端口自行设置（建议1000以上），密码自定义，混淆插件选：plain,配置完之后会打印一段配置信息，记得copy保存。如果忘记了，输入bash ssr.sh打开ssr主界面，选5看账号信息。这里注意一个坑，如果你ssr和bbr都配置好了，但就是连不上网且ping不通，打开ssr选7重新设置端口！有时候连不上是端口的问题。第三步安装加速这里有原版Google bbr、魔改版bbr、锐速、等加速算法选择，如果不设置加速，网速会非常慢！而且加速之间也有区别，如果搭配完发现网速太慢，可尝试换一种加速算法，具体教程网上基本都有，这里在下用的是魔改bbr。安装魔改版bbr1wget --no-check-certificate https://raw.githubusercontent.com/nanqinlang-tcp/tcp_nanqinlang/master/General/CentOS/bash/tcp_nanqinlang-1.3.2.sh &amp;&amp; bash tcp_nanqinlang-1.3.2.sh先输入1安装内核，安装完成后输入reboot重启服务器等待几分钟后，运行脚本1bash tcp_nanqinlang-1.3.2.sh选择2开启算法安装成功后会提示两句话1tcp_nanqinlang is installed !1tcp_nanqinlang is running !至此，梯子已经搭建完成。简单吧？搜索ssr客户端下载，填写配置信息后就能去查阅墙外的文献啦，这里就不贴下载链接了。友情贴一个外网的测速地址戳这里，还可以去试试访问Facebook，twitter,和youtube观看测试1080p视频的网速情况哦。谢谢观看]]></content>
      <categories>
        <category>网络知识</category>
      </categories>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人在hexo遇到的坑]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%B8%AA%E4%BA%BA%E5%9C%A8hexo%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[###1.下载百度提交链接模块遇到bug整百度SEO的时候，有个向百度提交自己网站地址的操作，安装了 “hexo-baidu-url-submit –save” 这个插件，网站认证是通过了.然而，我吃个晚饭回来准备继续整网站时,hexo clean &amp;&amp; hexo g &amp;&amp; hexo s一堆报错提示！当时内心简直崩溃！！！(才不会说是未保存就在本地调主题呢…这个bug我也没整懂，翻译意思好像是”Count”未赋值，一堆js文件里提示error:”Count”undefined，简直抓狂啊，这要怎么找bug！copy关键句怎样百度都没办法，甚至想到了克隆之前提交能跑的git仓库（结果没有克隆blog上传，git仓库里的是整合好的…)发现git仓库最近一次提交是19：22，于是只能用蠢办法翻chrome历史纪录查自己弄过什么插件了，照着历史纪录一个一个插件uninstall回去，改过的配置一一还原，最终通过报错的js文件，找到了源头”百度提交插件”的锅…npm uninstall hexo-baidu-url-submit –save ，得嘞 你给我滚回去吧(怒###2.fs.SyncWriteStream is deprecated关于这个错误，参考了这篇博主的文章：https://www.leiyawu.com/2018/02/28/hexo-fs-SyncWriteStream-is-deprecated/这里稍微贴下方法步骤吧npm install hexo-fs –save&emsp;更新hexo-fs插件问题出在：hexo-admin的hexo-fs因hexo-admin作为后台管理，无法npm uninstall hexo-admin卸载,则找到对应文件，注释：[root@server init]# grep -irn “SyncWriteStream” ./node_modules/hexo-admin/./node_modules/hexo-admin/node_modules/hexo-fs/lib/fs.js:718:exports.SyncWriteStream = fs.SyncWriteStream;[root@lywserver init]#将对应的exports.SyncWriteStream = fs.SyncWriteStream;注释(前面 //)即可！###3.蠢蠢的把网站下面运行时间的©打成了@,这个报错很好就找到了…]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
