<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2019%2F08%2F18%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[#用实际代码记录一下组件通信的使用吧（有点繁琐首先，也是在入口文件遍历注册组件for (const name in share) { Vue.component(name, share[name]) } // share component import pagination from &apos;@/share/pagination&apos; import tabs from &apos;@/share/tabs&apos; export default { pagination, tabs } 例子是一个分页组件，封装element ui分页组件的传值，使用时直接调用就行（封装意义在于多处用到&lt;template&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; //点击显示数目赋值 @current-change=&quot;handlePageChange&quot; //点击页数赋值 :current-page=&quot;config.page&quot; // 当前是第几页 :page-size=&quot;config.size&quot; // 用户选择一页显示多少条数据 :page-sizes=&quot;5&quot; // 应为一个数组存放一页显示多少条数据，初始化默认选择第一项 :total=&quot;total&quot; //总条目数 layout=&quot;total, sizes, prev, pager, next, jumper&quot; &gt;&lt;/el-pagination&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;share-pagination&apos;, //用props接收父组件传递的参数，父组件里为 :total=&apos;total&apos;动态绑定数据，传递给子组件 props: { total: { type: Number, default: 0 } }, data () { return { config: {} // 存放page和size } }, mounted () { this.initPage() //默认加载初始化方法 }, methods: { setConfig (config) { //接收到父组件传来的值 for (const key in config) { this.config[key] = config[key] //更新组件本地值 } this.$emit(&apos;change&apos;, this.config) //更新 }, initPage () { this.config = { // total接收父组件传的值，page和size自动初始化值 total: this.total, page: 1, size: this.$utils.getPageSizeOptions()[0] } this.$emit(&apos;change&apos;, this.config, true) }, handleSizeChange (val) { //改变页数/分页时，改变本地值 this.config.size = val this.configChange() }, handlePageChange (val) { //改变页数/分页时，改变本地值 this.config.page = val this.configChange() }, configChange () { this.config.total = this.total this.$emit(&apos;change&apos;, this.config) // 用$emit子到父组件通信，第一个参数change为父组件里调用子组件定义的接收函数的事件 // 例如&lt;子组件 :change=&quot;自定义函数&quot;&gt;&lt;/子组件&gt;第二个参数为传的值 } } } &lt;/script&gt; 父组件调用&lt;pagination :total=&quot;total&quot; ref=&quot;btnFind&quot; @change=&quot;paginationChange&quot;&gt; &lt;/pagination&gt; data () { return { paginationConfig: {}, total: 0, } }, methods: { paginationChange (config, men) { //接收子组件的值 this.paginationConfig = config this.getTableData() //改变页数时，调用接口更新切换页数要展示的数据 }, getPage () { // 此处为点击查询按钮，要将更新数据后页数初始化为1 this.$refs.btnFind.setConfig({page: 1}) // 通过绑定refs调用子组件方法 } } 贴个精简的父子组件通信例子吧父组件向子组件传值父组件定义:lists=&apos;list&apos;，:alert1=&apos;alert1&apos; 子组件用props:{&apos;lists:{}]&apos;,&apos;alert1:[]}&apos;}接收 注意props传值有两种情况，一种是固定传值，第二种是动态传值关于第二种动态传值，有两种方法用v-if 定义一个flag，初始为false，在动态改变了username的时候flag设置为true// 父组件 &lt;children :username=&quot;username&quot; v:if=&quot;flag&quot;/&gt; // 子组件 props: [&apos;username&apos;] 子组件通过watch监听数据变化 &lt;input type=&quot;text&quot; v-model=&quot;childrenData&quot;&gt; &lt;script&gt; export default { name: &quot;children&quot;, props:{ fatherData:String // 父组件绑定传的值 }, data(){ return{ childrenData:&apos;&apos; } }, created(){ this.childrenData=this.fatherData }, //这里用watch方法来监听父组件传过来的值，来实现实时更新 watch:{ //fatherData为props拿到的父组件值 fatherData(val){ this.childrenData = val //将父组件的值赋给childrenData 子组件的值 } } } 子组件中不使用props来接收父组件的方法子组件在methods中通过定义一个新方法，在方法体里面写this.$emit(‘父组件事件’, ‘参数1’)以这种形式获取父组件的方法，在赋值给子组件新定义的方法注意alert1是父组件中绑定时候自己定义的名字canshu1若该方法带参数则加上，不带则加空字符串即可//在父组件里 &lt;aler :data=&apos;data&apos; @alert1=&apos;sendData&apos;&gt;&lt;/aler&gt; function: sendData () { return &quot;这是父组件的值&quot; } //在子组件里 methods: { alert1 () { let data = this.$emit(&apos;alert1&apos;,&apos;&apos;) } } 简单概括&lt;msg ref=&quot;msg&quot; @myChange=&apos;change&gt;&lt;/msg&gt; //子组件触发change方法 methods: { //父组件通过ref调用子组件方法 ale() { this.$refs.msg.alert1() // 调用成功 } change(val) { console.log(val) // [1,2,3] } } //子组件里方法 alert1() { alert(&apos;调用成功&apos;) } change() { this.$emit(&apos;myChange&apos;,[1,2,3]) //监听自定义myChange事件 }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue自定义过滤器和动态绑定样式]]></title>
    <url>%2F2019%2F08%2F18%2Fvue%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[#直接贴用到过的代码吧…###记录一下，防止遗忘，顺便分享这里用到element ui的表格组件&lt;el-table :data=&quot;tableData&quot; :border=&quot;true&quot; stripe&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;id&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;level&quot; label=&quot;级别&quot;&gt; //比如获得的值是0、1、2，要判断转化成文本和调整样式 // scope.row获取此行的数据(在多条数据渲染内) &lt;template slot-scope=&apos;scope&apos;&gt; // 如果row.level == 1为真，则样式绑定为level-1 &lt;div :class=&quot;{ level-1: scope.row.level == 1, level-2: scope.row.level == 2}&quot;&gt; // 下面的level为main入口文件定义调用的方法，Vue.filter自定义过滤器 // 被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 {{ scope.row.level | level}} // 前者为要传的参数，| 后面为自定义的过滤函数 // 或者这种形式：&lt;div v-bind:id=&quot;scope.row.level| level&quot;&gt;&lt;/div&gt; {{ scope.row.level| level| isTrue }} //举例二 // level被定义为接收单个参数的过滤器函数，表达式 scope.row.level的值将作为参数传入到函数中。 // 然后继续调用同样被定义为接收单个参数的过滤器函数 isTrue ，将 level的结果传递到 isTrue 中。 {{ message | filterA('arg1', arg2) }} //举例三 // 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数， // 普通字符串 &apos;arg1&apos; 作为第二个参数，表达式 arg2 的值作为第三个参数。 &lt;/div&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; .level-1{ color: #c53535; } .level-2{ color: #FF9900; } 入口文件要注册过滤器//main.js import filterService from &apos;@/assets/filter&apos; //全局注册自定义过滤器Vue.filter，用for in将filter文件里的函数遍历出来 for (let transform in filter) { Vue.filter(transform, filter[transform]) } 存放自定义过滤器的文件function level(value) { let status = &apos;&apos; switch (value) { case 1: status = &apos;级别1&apos;; break case 2: status = &apos;级别2&apos;; break case 3: status = &apos;级别3&apos;; break default: status = &apos;error&apos; } return status } function isTrue (value) { return value ? &apos;是&apos; : &apos;否&apos; } // 定义参数接收全部函数，通过遍历将每个函数全局注册 let transform = { level: level, isTrue: isTrue } export default transform 除此之外，还可以在定义组件内部过滤，或者直接用计算属性、methods方法过滤&lt;ul&gt;&lt;li v-for=&quot;item in filterlist&quot;&gt;{{item}}&lt;/li&gt;&lt;/ul&gt; &lt;ul&gt;&lt;li v-for=&quot;item in filterTwo()&quot;&gt;{{item}}&lt;/li&gt;&lt;/ul&gt; computed: { filterlist () { // 拿到存在state.size的数组，意思是请求成功拿到的数据存到state // 要多行动态渲染的内容，直接绑定此方法 return处理好的数据 = 绑定一个数组 let num=this.size; return this.list.filter(function (number) { return number.id &lt; num }) } }, methods:{ filterTwo(val){ let num=this.size; return this.list.filter(function (number) { return number.id &lt; num }) }, addMore(){ this.size+=5; }, },]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios内部封装]]></title>
    <url>%2F2019%2F08%2F18%2Faxios%E5%86%85%E9%83%A8%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[#贴一下工作中用到的吧目录结构：├── service │ ├── index.js #用于统一定义接口地址，封装接口和使用封装好的请求方法 │ ├── baseService.js #调用config设置默认请求ip地址，响应器做超时处理，封装请求方法返回data └── config ├── index.js # 入口文件 ├── env.json # 更改要调用的角色的json文件 {&quot;dev&quot;: &quot;AAA&quot;} 改成BBB即调用BBB文件 ├── AAA.json # 角色A的ip └── BBB.json # 角色B的ip // 这里是用于多人开发时，对接不同后端接口的ip地址不同，后期会合并接口 最外层入口文件main.js，记得定义全局使用 Vue.prototype.$config = config Vue.prototype.$service = service 调用存放某人IP的JSON文件，暴露ip（作用是当开发时，多个后端的接口ip不同，修改调用哪个ip）// config index.js const env = require(&apos;./env.json&apos;).dev // 拿到AAA const config = require(&apos;./&apos; + env + &apos;.json&apos;) 拿到AAA.json const version = require(&apos;./version.json&apos;) //版本号，这里无用 config.version = version.version export default config // 暴露IP{&quot;apiUrl&quot;: &quot;http://0.0.0.0&quot;} 封装axios方法，配置请求地址为调用的默认ip + 后缀// baseService.js import axios from &apos;axios&apos; import Config from &apos;#/config/index&apos; // 默认请求地址 axios.defaults.baseURL = Config.apiUrl // 超时时间 axios.defaults.timeout = 10000 // 错误拦截器 axios.interceptors.response.use( function (response) { return response }, function (error) { // 对响应错误做点什么 return Promise.reject(error) } ) function get (url, request) { //url为: 默认设置好的IP地址 + index文件传来的接口后缀，request为传参 return axios.get(url, { params: request }).then(response =&gt; { return response[&apos;data&apos;] // 这里是返回data数据：{sta:&quot;00&quot;,data:{...}} }) } function post (url, request) { return axios.post(url, request).then(response =&gt; { return response[&apos;data&apos;] }) } function put (url, request) { return axios.put(url, request).then(response =&gt; { return response[&apos;data&apos;] }) } function patch (url, request) { return axios.patch(url, request).then(response =&gt; { return response[&apos;data&apos;] }) } function del (url, request) { if (request) { url = url + getUrlQuery(request) } return axios.delete(url).then(response =&gt; { return response[&apos;data&apos;] }) } function getUrlQuery (request) { let result = &apos;?&apos; let isFirst = true for (const key in request) { if (isFirst) { isFirst = false result += key + &apos;=&apos; + request[key] } else { result += &apos;&amp;&apos; + key + &apos;=&apos; + request[key] } } return result } export default { get, post, put, del, patch } 统一封装接口，调用封装好的axios方法// index.js import BaseService from &apos;./baseService.js&apos; function get (url, request) { return BaseService.get(url, request).then(response =&gt; { return response }) } function post (url, request) { return BaseService.post(url, request).then(response =&gt; { return response }) } function put (url, request) { return BaseService.put(url, request).then(response =&gt; { return response }) } function patch (url, request) { return BaseService.patch(url, request).then(response =&gt; { return response }) } function del (url, request) { return BaseService.del(url, request).then(response =&gt; { return response }) } /******************************/ function createService (url) { return { get: request =&gt; { return get(url, request) }, details: (id, request) =&gt; { return get(url + &apos;/&apos; + id, request) }, add: request =&gt; { return post(url, request) }, edit: (id, request) =&gt; { return put(url + &apos;/&apos; + id, request) }, del: id =&gt; { return del(url + &apos;/&apos; + id) } } } /******************************/ const User = createService(&apos;user&apos;) const login = request =&gt; { return post(&apos;login&apos;, request) } const logout= request =&gt; { return get(&apos;logout&apos;, request) } // 拼接url，调用时直接传：拼接值id、request请求参数 // 使用时，this.$封装的文件名.封装的接口名((id, {请求参数}).then(...) const del= (id, request) =&gt; { return del(&apos;del/&apos; + id, request) } ...... /******************************/ export default { User, login, logout, del } 贴一个网上的axios封装例子，可根据需求情况自行配置配置jsVue.use(Vuex) Vue.use(VueAxios, axios) Vue.use(qs) 注：qs，使用axios，必须得安装 qs，所有的Post 请求，我们都需要 qs,对参数进行序列化。 在 request 拦截器实现 axios.interceptors.request.use( config =&gt; { config.baseURL = &apos;/api/&apos; config.withCredentials = true // 允许携带token ,这个是解决跨域产生的相关问题 config.timeout = 6000 let token = sessionStorage.getItem(&apos;access_token&apos;) let csrf = store.getters.csrf if (token) { config.headers = { &apos;access-token&apos;: token, &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; } } if (config.url === &apos;refresh&apos;) { config.headers = { &apos;refresh-token&apos;: sessionStorage.getItem(&apos;refresh_token&apos;), &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; } } return config }, error =&gt; { return Promise.reject(error) } ) //在 response 拦截器实现 axios.interceptors.response.use( response =&gt; { // 定时刷新access-token if (!response.data.value &amp;&amp; response.data.data.message === &apos;token invalid&apos;) { // 刷新token store.dispatch(&apos;refresh&apos;).then(response =&gt; { sessionStorage.setItem(&apos;access_token&apos;, response.data) }).catch(error =&gt; { throw new Error(&apos;token刷新&apos; + error) }) } return response }, error =&gt; { return Promise.reject(error) } )]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由守卫与token验证配置例子]]></title>
    <url>%2F2019%2F08%2F18%2F%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E4%B8%8Etoken%E9%AA%8C%E8%AF%81%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[路由守卫、登陆验证token、axios全局配置及拦截器和响应器初次使用遇到了，顺便把记一下吧，较简略 还未完善先丢一个官网路由守卫的使用示例router.beforeEach((to, from, next) =&gt; { if (to.path === &apos;/login&apos;) { next() } else { // 登录验证 if (!store.state.isLogin) { // store状态设为true后，路由守卫放行 next(&apos;/login&apos;) } else { next() } } }) 这里的store.state.isLogin是放在全局状态里判断登录是否成功，默认false，如果登录成功后设置为true。(仅是一个例子，可根据自行爱好定义登陆页面login.vue，post请求成功后commit触发定义在mutation的login方法，将返回的token和用户信息传过去，然后把token（和用户信息）存到缓存中// sessionStorage用于临时保存在浏览器未关闭时 // 或用localStorage永久缓存，适用于（X天内自动登陆），记得设置过期时间 sessionStorage.setItem(&apos;user&apos;, this.form.username) store拿到数据后，保存token，设置全局axios请求头默认携带token，isLogin = true，转到首页state.token = token axios.defaults.headers.common[&apos;Authorization&apos;] = token state.isLogin = true store.state初始时，先触发方法去查找本地缓存是否有用户信息let data = sessionStorage.getItem(name) return data //注意存储的格式 //在状态管理里判断用户信息和token是否存在 if (sotreState &amp;&amp; sotreState.token) { sotreState.navbarActiveIndex = &apos;&apos; //初始化用在别处的状态 本例无用 sotreState.sidebarActiveIndex = &apos;&apos; //同上， axios.defaults.headers.common[&apos;Authorization&apos;] = sotreState.token //如果token存在，设置默认请求头携带token，初始状态 return sotreState } else { return initState() // 初始化store方法，全部清空 } 用户点击退出登陆时，触发logout方法，将store.state(和浏览器缓存)清空，跳回到登录页面转一个网上的例子一// http request 请求拦截器 // 作用是在发送请求前进行一些操作，例如在每个请求体里加上token axios.interceptors.request.use( config =&gt; { if (store.state.token) { // 判断是否存在token，如果存在的话，则每个http header都加上token config.headers.Authorization = `token ${store.state.token}`; } return config; }, err =&gt; { // 对响应错误做点什么 return Promise.reject(err); }); // http response 响应拦截器 // 作用是在接收到响应后进行一些操作，常用于统一配置错误状态提示，本例处理方法是将token信息清空 axios.interceptors.response.use( response =&gt; { return response; }, error =&gt; { if (error.response) { switch (error.response.status) { // 这里是后端返回错误码 case 401: // 返回 401 清除token信息并跳转到登录页面 store.commit(types.LOGOUT); // 派发清空状态(token)方法 router.replace({ path: &apos;login&apos;, query: {redirect: router.currentRoute.fullPath} }) } } return Promise.reject(error.response.data) // 返回接口返回的错误信息 }); 记一个处理思路0.每次打开网页，store初始化时，可以定义方法setItem判断本地缓存里是否有token信息，和验证是否过期，如果存在则赋值给state.token，设置axios请求默认携带state.token，路由放行第一次登录的时候，前端调后端的登陆接口，发送用户名和密码后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面前端每次跳转路由，就判断 localStroage（或在store设置Boolean值判断也行） 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面每次调后端接口，都要在请求头中加token后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401如果前端拿到状态码为401，就清除token信息并跳转到登录页面]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于echarts的X轴显示不全]]></title>
    <url>%2F2019%2F08%2F18%2Ftitle%2F</url>
    <content type="text"><![CDATA[关于echarts的X轴显示不全xAxis: { axisLabel: { interval:0, // x轴文字间隔显示 rotate:40 // x轴文字 - 旋转角度 //formatter: function (val) { // return val.split(&apos;&apos;).join(&apos;\n&apos;) // X轴文字竖放，可自行定义处理格式 // } } }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记for in 和 for of 的详细区别]]></title>
    <url>%2F2019%2F08%2F12%2F%E8%AE%B0for-in-%E5%92%8C-for-of-%E7%9A%84%E8%AF%A6%E7%BB%86%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[for in 和 for of 详细区别首先，先放出两者对比概念for…in 循环for…in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。for…in 语句用于对数组或者对象的属性进行循环操作。for … in 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作。for…in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。for…of 循环for … of循环是ES6引入的新的语法，用for … of循环遍历集合for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。这里直接记录下用法区分，用熟了概念也就掌握了首先，for in 和 for of 都可用于数组[1,2,3] 或 对象{“a”: 1, “b”: 2, “c”: 3}举个栗子，就能明白了//这是 for in let data = {&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3} for (let key in data) { lemp[Number(key)] = rdata[key] console.log(key) // 这里的key为data数组的索引/键名 console.log(data[key]) // 打印 1,2,3 } // 注意 for in 循环可能会乱序，有顺序要求请用for遍历索引 // 注意 for in 会遍历所有可枚举属性，例如原型链上的方法和属性，可通过hasOwnProperty(key)判断：某属性是否为该对象的实例属性 // 注意 for in 遍历的索引为字符串型数字 // for in更适合遍历对象属性， 炒板栗//这是for of let data1 = [1, 2, 3, 4] let data2 = [{&apos;name&apos;:张三, &apos;id&apos;: 01}, {&apos;name&apos;:李四, &apos;id&apos;: 02}] //下面循环偷懒写一次... for (let key of data) { console.log(key) // 循环data1时，打印 1,2,3,4 console.log(key.name) // 循环data2时，此处的key可看成是 data2[0],data2[1]，即打印 张三，李四 } // for of可遍历：数组/数组对象/字符串/map/set等都适用，但不能遍历对象{ },如要使用，可用Object.keys(data)循环属性，或Object.values(obj)循环属性值 // for of遍历的只是数组内的元素，而不包括原型 // for of更适合遍历数据，例如数组的值 补一个foreach循环let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] arr.forEach(function (val, idx, arr) { console.log(val + &apos;, index = &apos; + idx) // val是当前元素，index当前元素索引，arr数组 console.log(arr) })]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下axios食用方法，以及工作中遇到的坑]]></title>
    <url>%2F2019%2F07%2F28%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Baxios%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[初上手axios真的被坑一脸血（摊上个不靠谱的同事有毒首先放一下axios的食用姿势 //这是get方法 axios.get(&apos;/user?ID=12345&apos;) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); //这是post方法 axios.post(&apos;/user&apos;, { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); //推荐统一用api方法 axios({ method: &apos;post&apos;, url: &apos;/user/12345&apos;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot; } data: { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; } }); 在使用GET方法传递参数时使用的是params，并且官方文档中介绍为：params are the URL parameters to be sent with the request. Must be a plain object or a URLSearchParams object。plain object（纯对象）是指用JSON形式定义的普通对象或者new Object()创建的简单对象；而URLSearchParams object指的是一个可以由URLSearchParams接口定义的一些实用方法来处理 URL 的查询字符串的对象，也就是说params传参是以/user?ID=1&amp;name=mike&amp;sex=male形式传递的(意思是get请求会以数据附加到URL地址后面的形式，一起传给后台而在使用POST时对应的传参使用的是data，data是作为请求体发送的，同样使用这种形式的还有PUT，PATCH等请求方式。也就是说使用的是序列化后的json格式字符串来传递参数，如：{ “name” : “mike”, “sex” : “male” }；同时，后台必须要以支持@RequestBody的形式接收参数，否则会出现前台传参正确，后台接收不到的情况。axios引入就不说了，这里在下项目用的是vue-axios重点说一下，axios有三种常见的数据请求格式Content-Type: application/json ： 请求体中的数据会以json字符串的形式发送到后端Content-Type: application/x-www-form-urlencoded：请求体中的数据会以普通表单形式（键值对）发送到后端Content-Type: multipart/form-data： 它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。axios默认的请求头是第一种：Content-Type: application/json，并且在axios中会默认把数据序列化成JSON字符串格式。对于第二种格式：application/x-www-form-urlencoded的传参用 URLSearchParams API传递参数let param = new URLSearchParams() param.append(&apos;username&apos;, &apos;admin&apos;) param.append(&apos;pwd&apos;, &apos;admin&apos;) axios({ method: &apos;post&apos;, url: &apos;/api, data: param }) 需要注意的是： URLSearchParams 不支持所有的浏览器，但是总体的支持情况还是 OK 的，所以优先推荐这种简单直接的解决方案修改axios默认的请求头axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 或者直接在api里更改 {headers:{&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;}} 之后引入qs库的Qs.stringify方法 import Qs from &apos;qs&apos; let data = { &quot;username&quot;: &quot;admin&quot;, &quot;pwd&quot;: &quot;admin&quot; } axios({ headers: { &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; }, method: &apos;post&apos;, url: &apos;/api/xxx&apos;, data: Qs.stringify(data) }) 修改axios源码中的transformRequestimport Qs from &apos;qs&apos; axios({ url: &apos;/api/lockServer/search&apos;, method: &apos;post&apos;, transformRequest: [function (data) { // 对 data 进行任意转换处理 return Qs.stringify(data) }], headers: { &apos;deviceCode&apos;: &apos;A95ZEF1-47B5-AC90BF3&apos; }, data: { username: &apos;admin&apos;, pwd: &apos;admin&apos; } }) 手动连结axios.post(&apos;/api/lockServer/search&apos;,&quot;userName=&apos;admin&apos;&amp;pwd=&apos;admin&apos;&quot;); 对于第三种格式：Content-Type: multipart/form-data的传参对于这种类型的数据，我们常见前端页面上传个人图像，然后点击保存发送后端修改原始数据。1234567891011121314151617let params = new FormData()params.append(&apos;file&apos;, this.file)params.append(&apos;id&apos;, localStorage.getItem(&apos;userID&apos;))params.append(&apos;userName&apos;, this.name)params.append(&apos;sex&apos;, this.sex)params.append(&apos;mobile&apos;, this.phone)params.append(&apos;email&apos;, this.email)params.append(&apos;qq&apos;, this.qq)params.append(&apos;weChat&apos;, this.WeChat)axios.post(URL, params, &#123;headers: &#123;&apos;Content-Type&apos;: &apos;multipart/form-data&apos;&#125;&#125;).then(res =&gt; &#123;if (res.data.code === 0) &#123;this.$router.go(-1)&#125;&#125;).catch(error =&gt; &#123;alert(&apos;更新用户数据失败&apos; + error)&#125;)后记，错误500多半是服务器问题，打印下自己的数据格式，看跟接口要求的格式是否一样，然后就是后端的锅了。错误403是服务器拒绝访问，叫后端开接口，检查下自己URL有没输错。错误404，请求内容不存在。错误408，请求超时。301，重定向。200，返回正确结果即成功。这里推荐模拟请求接口的软件postman，拿到接口先测一遍（便于甩锅另外，axios可以在全局配置请求头，请求格式，拦截器等，具体请参考官方文档，使用例子有登陆拦截配置token过期验证处理，把axios方法封装成自定义api……]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个十分简单的git教程网站]]></title>
    <url>%2F2019%2F06%2F03%2F%E4%B8%80%E4%B8%AA%E5%8D%81%E5%88%86%E7%AE%80%E5%8D%95%E7%9A%84git%E6%95%99%E7%A8%8B%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[分享链接:git - the simple guide支持中文，需翻墙]]></content>
  </entry>
  <entry>
    <title><![CDATA[记录一下vps的搭建过程]]></title>
    <url>%2F2019%2F06%2F02%2Fvps%2F</url>
    <content type="text"><![CDATA[首先，你得先有一台服务器例如抛瓦工、vultr之类的，自己去比较哪家性价比好点，想当梯子用的话必须买外国的服务器哦。怎么购买就不多说了，网上教程一大把，还支持支付宝/微信充值，这里仅记录一下成功搭建的过程。首先购买到服务器之后，在控制台找到你服务器的IP，先去找个海外网速测速网站测试一下：测速网站 这里勾去外网只选国内，可以看到服务器ip与大陆各地区之间的延迟（如果通通超时的话，就是ip被ban了）ip被ban的话只能更换ip了，xshell连不上服务器同理。服务器系统建议选centOS6 64或7 64，网上教程普遍为6，但cenntOS7好像也没问题。选好服务器之后，在你本地电脑里下一个xshell用来连接服务器新建主机名填服务器ip用户身份验证里，id普遍为root，密码填你服务器随机分配的密码登陆成功后，控制台提示如图五个流程搞定第一步yum -y install wget第二步安装中文版ssr1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh进去界面是中文的，非常简单！输入：1 安装ShadowsocksR，端口自行设置（建议1000以上），密码自定义，混淆插件选：plain,配置完之后会打印一段配置信息，记得copy保存。如果忘记了，输入bash ssr.sh打开ssr主界面，选5看账号信息。这里注意一个坑，如果你ssr和bbr都配置好了，但就是连不上网且ping不通，打开ssr选7重新设置端口！有时候连不上是端口的问题。第三步安装加速这里有原版Google bbr、魔改版bbr、锐速、等加速算法选择，如果不设置加速，网速会非常慢！而且加速之间也有区别，如果搭配完发现网速太慢，可尝试换一种加速算法，具体教程网上基本都有，这里在下用的是魔改bbr。安装魔改版bbr1wget --no-check-certificate https://raw.githubusercontent.com/nanqinlang-tcp/tcp_nanqinlang/master/General/CentOS/bash/tcp_nanqinlang-1.3.2.sh &amp;&amp; bash tcp_nanqinlang-1.3.2.sh先输入1安装内核，安装完成后输入reboot重启服务器等待几分钟后，运行脚本1bash tcp_nanqinlang-1.3.2.sh选择2开启算法安装成功后会提示两句话1tcp_nanqinlang is installed !1tcp_nanqinlang is running !至此，梯子已经搭建完成。简单吧？搜索ssr客户端下载，填写配置信息后就能去查阅墙外的文献啦，这里就不贴下载链接了。友情贴一个外网的测速地址戳这里，还可以去试试访问Facebook，twitter,和youtube观看测试1080p视频的网速情况哦。谢谢观看]]></content>
      <categories>
        <category>网络知识</category>
      </categories>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人在hexo遇到的坑]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%B8%AA%E4%BA%BA%E5%9C%A8hexo%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[###1.下载百度提交链接模块遇到bug整百度SEO的时候，有个向百度提交自己网站地址的操作，安装了 “hexo-baidu-url-submit –save” 这个插件，网站认证是通过了.然而，我吃个晚饭回来准备继续整网站时,hexo clean &amp;&amp; hexo g &amp;&amp; hexo s一堆报错提示！当时内心简直崩溃！！！(才不会说是未保存就在本地调主题呢…这个bug我也没整懂，翻译意思好像是”Count”未赋值，一堆js文件里提示error:”Count”undefined，简直抓狂啊，这要怎么找bug！copy关键句怎样百度都没办法，甚至想到了克隆之前提交能跑的git仓库（结果没有克隆blog上传，git仓库里的是整合好的…)发现git仓库最近一次提交是19：22，于是只能用蠢办法翻chrome历史纪录查自己弄过什么插件了，照着历史纪录一个一个插件uninstall回去，改过的配置一一还原，最终通过报错的js文件，找到了源头”百度提交插件”的锅…npm uninstall hexo-baidu-url-submit –save ，得嘞 你给我滚回去吧(怒###2.fs.SyncWriteStream is deprecated关于这个错误，参考了这篇博主的文章：https://www.leiyawu.com/2018/02/28/hexo-fs-SyncWriteStream-is-deprecated/这里稍微贴下方法步骤吧npm install hexo-fs –save&emsp;更新hexo-fs插件问题出在：hexo-admin的hexo-fs因hexo-admin作为后台管理，无法npm uninstall hexo-admin卸载,则找到对应文件，注释：[root@server init]# grep -irn “SyncWriteStream” ./node_modules/hexo-admin/./node_modules/hexo-admin/node_modules/hexo-fs/lib/fs.js:718:exports.SyncWriteStream = fs.SyncWriteStream;[root@lywserver init]#将对应的exports.SyncWriteStream = fs.SyncWriteStream;注释(前面 //)即可！###3.蠢蠢的把网站下面运行时间的©打成了@,这个报错很好就找到了…]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
