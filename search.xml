<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue实现权限路由的姿势及踩坑]]></title>
    <url>%2F2019%2F09%2F17%2Fvue%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E8%B7%AF%E7%94%B1%E7%9A%84%E5%A7%BF%E5%8A%BF%E5%8F%8A%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[记录一下自己用到的路由权限简易实现第一次实习就遇上这个大难点，本菜鸟翻阅了大量的资料，踩过了一堆坑之后才有了实现过程，希望尽量能写的简单易懂点，有错误的地方望指正。 路由权限基本实现的几种方式思路（由易到难）首先要知道，在route.js只能通过钩子函数操纵数据，直接push会导致搭配的路由懒加载失效，而且是无法对route树进行操作的…至少你无法删除已生成的路由。(本文假装你已经有了vue基础) 其实核心都是基于beforeEach、meta元信息、和addRoutes进行操作的，区别只是姿势和效果不同 最简单的基于meta元信息中自定义的规则判断，路由隐藏也是这么实现的。 举个栗子：下面是一段二级菜单的部分路由，比如淘宝首页点进去母婴用品，下面还有二级列表就好理解了吧 { path: &apos;/&apos;, name: &apos;/&apos;, redirect: &apos;index&apos;, // 这是重定向 component: resolve =&gt; require([&apos;@/components/Menu.vue&apos;], resolve), children: [ { path: &apos;index&apos;, meta: { moduleName: &apos;首页&apos;, hidden: false, role: [&apos;index&apos;] }, component: resolve =&gt; require([&apos;@/components/index.vue&apos;], resolve) }, ] } 那么则可以在meta自定义规则信息，比如说标识一个hidden布尔值，那么在渲染路由时，可以通过v-if、v-show等隐藏渲染路由（注意路由依旧生成了，通过url或route.push是可以跳进去的） 路由权限同理，可以定义一个变量数组[]接收权限标识符，路由少的可以每个分配唯一标识符，路由或角色多的能分配共同拥有相同的标识符......由你喜欢 之后只需要在beforeEach里判断meta准许进入，无权限则跳转403什么的... boforeEach还可以做登录拦截，这里就不提了。 **这种方法能渲染全部路由，实现起来简单。** **缺点是：每次跳转路由都要判断做权限判断，而且加载的路由太多的话，会对性能有影响。而且菜单是写死的**（不太推荐） 还有一种是登录页分离的方式 非vue的单页应用，就是单独的登录页成功后，将匹配的权限传递给主页面应用（可以看成是两个网站的跳转…），然后筛选路由列表渲染。（没用过，感兴趣的同学可以上网找点教程试试 剩下的都是用addRoutes以动态加载的方式实现（略复杂 由后端返回权限菜单列表，前端匹配处理 （本菜鸟项目中用的就是这种方式） 首先，将需要动态加载的路由抽成一个新的文件，分为默认路由和动态路由 const defaultRouterMap = [ { path: &apos;/login&apos;, component: resolve =&gt; require([&apos;@/components/Login.vue&apos;], resolve) }, { path: &apos;*&apos;, component: resolve =&gt; require([&apos;@/components/404.vue&apos;], resolve) } ] const router = new Router({ mode: &apos;history&apos;, routes: defaultRouterMap }) 上面是默认加载渲染的页面（总不能让人家连登录页都进不去吧ww） 抽出来的路由也是相同的结构，只是meta里多了个自定义的规则，比如 rule: [&apos;mother&apos;,&apos;son&apos;...] 基本叙述一下大概思路： 1. 登录成功后，将用户信息、token、权限列表、登录状态等存到store中 2. beforeEach判断登录状态存在，放行到下一步 3. 在store定义一个空变量存放新路由（或者存到sessionStorage），beforeEach判断是否为第一次登录加载路由，例如if(store.state.newRoute.length == 0) 4. 匹配权限列表，筛选出符合的路由数据 5. 将新的路由存到store的newRoute中（目的是之后的页面跳转统统放行）addRoutes生成插入的路由 6. 用户退出登录时，将store(或网页缓存)清空，用**location.reload()**方法强制刷新网页（因为vue是单页面应用，生成的路由会一直在页面中存在，而且vue-route官方没有删减路由的api......有另外更好的方法请告诉我） **下面是大致要点和踩到的坑** 由于路由数据是个树结构，处理起来还是有点复杂的。本菜鸟的项目中后端返回是一个数组形式的字符串列表：如[&apos;A&apos;,&apos;B&apos;,&apos;Son&apos;,&apos;SuperUser&apos;...] 讨论的设计是：后端返回一个代表某角色所拥有的全部权限的列表，前端路由在meta.XXX中为每个路由设定一个唯一字符串，遍历匹配如果字符串不存在，则删除路由节点。 贴个大概的处理步骤作参考，（同事大佬提供了大部分实现，瑟瑟发抖， 尽量标清楚作用，这里只是处理路由数据的参考，各人实际情况不同，加油自己实现鸭（下面目的仅仅只是返回一个处理好的待生成路由，本菜鸟优化不下去了 function routeMatch (asyncRouterMap = [], routePower = []) { // 旧路由数据，权限列表 let newRoute = Object.assign({}, asyncRouterMap[0]) // 返回的新路由 function createRouter (Router) { let i = 0 while (i &lt; Router.children.length) { let router = Router.children[i] if (router.children) { // 这里的作用是递归遍历每一项的最深处 createRouter(router) } if (router.meta &amp;&amp; router.meta.role) { // 如果没设置meta的，默认放行 let has = false for (let key of router.meta.role) { if (hasRole(routePower, key)) { // 如果权限存在，跳出循环 has = true break } } if (has) { i++ } else { Router.children.splice(i, 1) // 如果meta匹配失败，删除路由 } } else { i++ } } } createRouter(newRoute) // 判断重定向 &amp;&amp; 若一级模块下的子路由都不存在权限，则删除一级模块 let i = newRoute.children.length let newMap = newRoute.children while (i--) { if (newMap[i].children &amp;&amp; newMap[i].children.length &gt; 1) { if (newMap[i].children[0].redirect !== newMap[i].children[1].path) { newMap[i].children[0].redirect = newMap[i].children[2].path } } else if (newMap[i].children &amp;&amp; newMap[i].children.length &lt;= 1) { newMap.splice(i, 1) // 删除一级路由 } } if (newRoute.redirect !== newRoute.children[0].path) { // 改变重定向 newRoute.redirect = newRoute.children[0].path } return newRoute } function hasRole (roles, key) { // 判断权限列表中是否含有meta.XXX return roles.includes(key) } ``` 由于这里实现的是二级菜单，到这里就结束了。更多级菜单嵌套，可能需要更加优化的手段处理，自己尝试啦~ 之后便是生成路由，**注意：这里有个小坑 next(to)括号里必须加to，如果是next()的话会出现，路由加载成功但跳转的页面是空白页的情况（坑的好惨，怀疑是先后顺序的问题，用异步调试的跟打断点似的，最后偶尔瞥到了解决方案......** if (routersArr.length === 0) { routersArr = routeMatch(asyncRouterMap, store.state.routePower) store.commit(&apos;setRoute&apos;, routersArr) router.addRoutes([routersArr]) next(to) } else { next() } 退出登录时，记得清除store数据 - **路由列表完全由后端返回（甩锅一身轻** 有个问题是后端返回的 **&apos;() =&gt; import(&apos;@/pages/Login.vue&apos;)&apos;** ，如果不是出现在前端，webpage似乎不会对其进行编译打包... 前端可抽出一个文件对应compoent，像actionType那样 const A = () =&gt; import(&quot;../pages/Home.vue&quot;); const B = () =&gt; import(&quot;../pages/UserInfo.vue&quot;); export default { typeA: A, typeB: B }; -------------------------- // 后端返回的数据 { path: &apos;A&apos;, component: typeA } 后续坑点回顾 加载路由后跳转要使用next(to) 重定向问题：如果重定向页面不存在，会导致空白页问题。匹配父路由的children中，重定向路由与其下一位路由的redirect是否相等，动态更改重定向的path就ok了。 清除路由可以手动刷新页面… 暂时不会权限细微到按钮，太难了 无助、弱小、但能吃……. 本文参考了下述资料，非常感谢大佬们的教程，对俺实现项目提供了很大的帮助 https://juejin.im/post/5b5bfd5b6fb9a04fdd7d687a#heading-12 https://juejin.im/post/5c7bae3ff265da2db27950f3#heading-4]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一段有趣的css]]></title>
    <url>%2F2019%2F09%2F17%2F%E4%B8%80%E6%AE%B5%E6%9C%89%E8%B6%A3%E7%9A%84css%2F</url>
    <content type="text"><![CDATA[css布局能看到不同深度的节点，颜色的变化。方便更好的看到每个元素的 大小、边距、填充 * { background-color: rgba(255,0,0,.2); } * * { background-color: rgba(0,255,0,.2); } * * * { background-color: rgba(0,0,255,.2); } * * * * { background-color: rgba(255,0,255,.2); } * * * * * { background-color: rgba(0,255,255,.2); } * * * * * * { background-color: rgba(255,255,0,.2); } * * * * * * * { background-color: rgba(255,0,0,.2); } * * * * * * * * { background-color: rgba(0,255,0,.2); } * * * * * * * * * { background-color: rgba(0,0,255,.2); } 效果如下：（感觉调布局的时候挺好玩的]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[唠叨一篇防抖调用姿势及的vue生命周期基本使用]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%94%A0%E5%8F%A8%E4%B8%80%E7%AF%87%E9%98%B2%E6%8A%96%E8%B0%83%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%8F%8A%E7%9A%84vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[唠叨一篇防抖调用姿势引发的vue生命周期基本使用本例遇到的坑是，写好的防抖/节流方法怎么会调用失败？… 失败情况长这个样子： debounce(){console.log(&apos;触发&apos;)} -------------------------- 点击一次触发: (1)&apos;触发&apos; &gt;看起来像是实现了 ----------------------- 一秒内疯狂点击触发: 结果是定时完成后，一下子全部打印了 (63)&apos;触发&apos; 根据多方查阅，得知是调用姿势有问题。本菜鸟认为是绑定问题，生成了多个定时器…希望有大佬能告诉下是什么原理，记着笔记先…… 在data里定义方法去调用防抖函数 // 效果感觉是生成dom实例后，渲染数据是绑定了唯一的对象，所以调用创建时不会生成多个 data () { keyup: () =&gt; {} //效果等同于在data里写死方法: //keyup: this.$utils.debounce.(this.func, 1000) }, created () { this.keyup = this.$utils.debounce.(this.func, 1000) } methods () { func () { console.log(&apos;一秒一次&apos;) } } 用nextTick发布事件委托(关闭页面前得注销事件委托，不然每次打开页面都会新建一个，造成大量开销（卡死) // nextTick作用是dom数据更新后执行，生成在作用队列例如定时器，会事件循环。 //可用于如dom渲染完成前，要在created进行dom操作，这时使用nextTick异步到dom渲染完成后，再进行（真实存在）dom操作 // 关于nextTick稍后会详细说 mounted () { this.$nextTick(() =&gt; { document.getElementById(&apos;inputID&apos;).addEventListener(&apos;keyup&apos;, this.$utils.debounce(this.func, 1000)) }) }, beforeDestroy () { document.getElementById(&apos;inputID&apos;).removeEventListener(&apos;keyup&apos;, this.$utils.debounce(this.func, 1000)) } 使用观察者发布订阅（按理说有大量的网上例子是这么说的，看起来好像没问题，可能也是我的姿势不对 // watch稍后也会详细说，这里的原理是监听到数据变化时，调用函数处理 data() { submitData: { EditEMail: &apos;&apos; } }, watch: { &apos;submitData.EditEMail&apos;: { handler(val) { this.EditEMailValid({ vm: this, val, verifyEmail}); }, immediate: true, //最初绑定时也执行函数 deep: true //深度监听 } }, methods: { EditEMailValid: debounce(({ vm, val, verifyEmail }) =&gt; { ... your code }, 1000), } 这里稍微说下防抖和节流的大概功能作用吧： 两者期望的作用都是降低函数的触发频率，节省性能开销 实现的关键是内部闭包的定时器的创建和消除，通过验证通过进入闭包时，清除定时器再创建一个新的 涉及到this指向不是当前vue实例的问题，采取传入this 或老方法用变量创建this，在闭包内保存使用 两者的区别为：防抖是读条法师；节流是cd法师（前者能打断读条，后者有固定cd 一般使用：定时器或时间戳判断，也可以两者共用严格判断 关于nextTick: 首先在vue中进行dom操作是异步的。 举个栗子，想要在created()这个周期进行初始化操作dom时，使用nextTick可回调到dom挂载渲染完成后处理，避免了dom未渲染完成时，操作dom发生报错。上面的防抖函数调用失败就是这个问题( 在监听数据变化后要进行某些操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。 引用官方文档: Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。 例如，当你设置vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 nextTick的原理大概可以看成是使用了promise、或setTimeout，dom操作建议使用nextTick异步执行，详细的源码解析可以参考网上大佬们的博客。 computed是计算属性有过滤作用，而watch是观察和响应数据的变化官方示例： 观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。 举个栗子： data: { one: &apos;this is one&apos;, two: &apos;this is two&apos; } watch: { &apos;one&apos;: { handler(val) { this.EditEMailValid({ vm: this, val, verifyEmail}); }, immediate: true, // immediate表示第一次被绑定值时就执行一次 deep: true // deep表示深度监听，会深度遍历每层都设置监听器，默认false，不开启时只能监听到第一层 // 如果感觉开销会很大，可以采取字符串&apos;one.a.nextA&apos;的的形式，代表绑定到指定对象才设置监听器 } watch大致原理是遍历数据的每一项使用watcher包装，handler放入到watcher更新函数中，就像vue的响应式原理一样，set当数据改变时就会通知watcher更新，调用设置好的handler函数。immediate 就是get读取到值时就调用一次回调更新。感兴趣的可以去掘金找找关于watch源码的解析，挺多篇的… 关于生命周期官网贴了流程图，多看几遍挺有用的… 大概分为： beforeCreate 实例创建前（初始化页面前） created （初始化页面后） beforeMount 挂载前（dom渲染前） mounted 挂载后（dom渲染完成） beforeUpdate 更新前 updated 更新完成 beforeDestory（卸载组件前） destroyed（卸载组件前） 稍微注意一下： beforeCreate：是new Vue()之后触发的第一个钩子，data、mounted等数据和方法均不可调用 created：阶段可以进行数据初始化、操控，如果要进行dom操作，使用nextTick方法 beforeMount：虚拟Dom已经创建完成，即将开始渲染。（在下用的少… mounted：真实dom挂载完成，用$ref操作dom，和页面初始化获取请求数据的方法等能写在这 beforeUpdate： 发生在虚拟dom更新之前触发，在当前阶段进行更改数据，不会造成重渲染，如手动移除已添加的事件监听器 updated： 发生在dom更新完成之后，可执行依赖与DOM的操作，避免更改数据以导入无限循环 beforeDestory： 实例销毁之前调用，可清理定时器等收尾任务 destoryed：发生在实例销毁之后，这时dom只剩下了空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。（听起来是不是有种史诗感？XD 先到这吧……感谢观看！]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2019%2F08%2F18%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[#用实际代码记录一下组件通信的使用吧（有点繁琐 首先，也是在入口文件遍历注册组件 for (const name in share) { Vue.component(name, share[name]) } // share component import pagination from &apos;@/share/pagination&apos; import tabs from &apos;@/share/tabs&apos; export default { pagination, tabs } 例子是一个分页组件，封装element ui分页组件的传值，使用时直接调用就行（封装意义在于多处用到 &lt;template&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; //点击显示数目赋值 @current-change=&quot;handlePageChange&quot; //点击页数赋值 :current-page=&quot;config.page&quot; // 当前是第几页 :page-size=&quot;config.size&quot; // 用户选择一页显示多少条数据 :page-sizes=&quot;5&quot; // 应为一个数组存放一页显示多少条数据，初始化默认选择第一项 :total=&quot;total&quot; //总条目数 layout=&quot;total, sizes, prev, pager, next, jumper&quot; &gt;&lt;/el-pagination&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;share-pagination&apos;, //用props接收父组件传递的参数，父组件里为 :total=&apos;total&apos;动态绑定数据，传递给子组件 props: { total: { type: Number, default: 0 } }, data () { return { config: {} // 存放page和size } }, mounted () { this.initPage() //默认加载初始化方法 }, methods: { setConfig (config) { //接收到父组件传来的值 for (const key in config) { this.config[key] = config[key] //更新组件本地值 } this.$emit(&apos;change&apos;, this.config) //更新 }, initPage () { this.config = { // total接收父组件传的值，page和size自动初始化值 total: this.total, page: 1, size: this.$utils.getPageSizeOptions()[0] } this.$emit(&apos;change&apos;, this.config, true) }, handleSizeChange (val) { //改变页数/分页时，改变本地值 this.config.size = val this.configChange() }, handlePageChange (val) { //改变页数/分页时，改变本地值 this.config.page = val this.configChange() }, configChange () { this.config.total = this.total this.$emit(&apos;change&apos;, this.config) // 用$emit子到父组件通信，第一个参数change为父组件里调用子组件定义的接收函数的事件 // 例如&lt;子组件 :change=&quot;自定义函数&quot;&gt;&lt;/子组件&gt;第二个参数为传的值 } } } &lt;/script&gt; 父组件调用 &lt;pagination :total=&quot;total&quot; ref=&quot;btnFind&quot; @change=&quot;paginationChange&quot;&gt; &lt;/pagination&gt; data () { return { paginationConfig: {}, total: 0, } }, methods: { paginationChange (config, men) { //接收子组件的值 this.paginationConfig = config this.getTableData() //改变页数时，调用接口更新切换页数要展示的数据 }, getPage () { // 此处为点击查询按钮，要将更新数据后页数初始化为1 this.$refs.btnFind.setConfig({page: 1}) // 通过绑定refs调用子组件方法 } } 贴个精简的父子组件通信例子吧 父组件向子组件传值 父组件定义:lists=&apos;list&apos;，:alert1=&apos;alert1&apos; 子组件用props:{&apos;lists:{}]&apos;,&apos;alert1:[]}&apos;}接收 注意props传值有两种情况，一种是固定传值，第二种是动态传值 关于第二种动态传值，有两种方法 用v-if 定义一个flag，初始为false，在动态改变了username的时候flag设置为true // 父组件 &lt;children :username=&quot;username&quot; v:if=&quot;flag&quot;/&gt; // 子组件 props: [&apos;username&apos;] 子组件通过watch监听数据变化 &lt;input type=&quot;text&quot; v-model=&quot;childrenData&quot;&gt; &lt;script&gt; export default { name: &quot;children&quot;, props:{ fatherData:String // 父组件绑定传的值 }, data(){ return{ childrenData:&apos;&apos; } }, created(){ this.childrenData=this.fatherData }, //这里用watch方法来监听父组件传过来的值，来实现实时更新 watch:{ //fatherData为props拿到的父组件值 fatherData(val){ this.childrenData = val //将父组件的值赋给childrenData 子组件的值 } } } 子组件中不使用props来接收父组件的方法 子组件在methods中通过定义一个新方法，在方法体里面写this.$emit(‘父组件事件’, ‘参数1’) 以这种形式获取父组件的方法，在赋值给子组件新定义的方法 注意alert1是父组件中绑定时候自己定义的名字 canshu1若该方法带参数则加上，不带则加空字符串即可 //在父组件里 &lt;aler :data=&apos;data&apos; @alert1=&apos;sendData&apos;&gt;&lt;/aler&gt; function: sendData () { return &quot;这是父组件的值&quot; } //在子组件里 methods: { alert1 () { let data = this.$emit(&apos;alert1&apos;,&apos;&apos;) } } 简单概括 &lt;msg ref=&quot;msg&quot; @myChange=&apos;change&gt;&lt;/msg&gt; //子组件触发change方法 methods: { //父组件通过ref调用子组件方法 ale() { this.$refs.msg.alert1() // 调用成功 } change(val) { console.log(val) // [1,2,3] } } //子组件里方法 alert1() { alert(&apos;调用成功&apos;) } change() { this.$emit(&apos;myChange&apos;,[1,2,3]) //监听自定义myChange事件 }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue自定义过滤器和动态绑定样式]]></title>
    <url>%2F2019%2F08%2F18%2Fvue%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[#直接贴用到过的代码吧… ###记录一下，防止遗忘，顺便分享 这里用到element ui的表格组件 &lt;el-table :data=&quot;tableData&quot; :border=&quot;true&quot; stripe&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;id&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;level&quot; label=&quot;级别&quot;&gt; //比如获得的值是0、1、2，要判断转化成文本和调整样式 // scope.row获取此行的数据(在多条数据渲染内) &lt;template slot-scope=&apos;scope&apos;&gt; // 如果row.level == 1为真，则样式绑定为level-1 &lt;div :class=&quot;{ level-1: scope.row.level == 1, level-2: scope.row.level == 2}&quot;&gt; // 下面的level为main入口文件定义调用的方法，Vue.filter自定义过滤器 // 被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 {{ scope.row.level | level}} // 前者为要传的参数，| 后面为自定义的过滤函数 // 或者这种形式：&lt;div v-bind:id=&quot;scope.row.level| level&quot;&gt;&lt;/div&gt; {{ scope.row.level| level| isTrue }} //举例二 // level被定义为接收单个参数的过滤器函数，表达式 scope.row.level的值将作为参数传入到函数中。 // 然后继续调用同样被定义为接收单个参数的过滤器函数 isTrue ，将 level的结果传递到 isTrue 中。 {{ message | filterA('arg1', arg2) }} //举例三 // 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数， // 普通字符串 &apos;arg1&apos; 作为第二个参数，表达式 arg2 的值作为第三个参数。 &lt;/div&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; .level-1{ color: #c53535; } .level-2{ color: #FF9900; } 入口文件要注册过滤器 //main.js import filterService from &apos;@/assets/filter&apos; //全局注册自定义过滤器Vue.filter，用for in将filter文件里的函数遍历出来 for (let transform in filter) { Vue.filter(transform, filter[transform]) } 存放自定义过滤器的文件 function level(value) { let status = &apos;&apos; switch (value) { case 1: status = &apos;级别1&apos;; break case 2: status = &apos;级别2&apos;; break case 3: status = &apos;级别3&apos;; break default: status = &apos;error&apos; } return status } function isTrue (value) { return value ? &apos;是&apos; : &apos;否&apos; } // 定义参数接收全部函数，通过遍历将每个函数全局注册 let transform = { level: level, isTrue: isTrue } export default transform 除此之外，还可以在定义组件内部过滤，或者直接用计算属性、methods方法过滤 &lt;ul&gt;&lt;li v-for=&quot;item in filterlist&quot;&gt;{{item}}&lt;/li&gt;&lt;/ul&gt; &lt;ul&gt;&lt;li v-for=&quot;item in filterTwo()&quot;&gt;{{item}}&lt;/li&gt;&lt;/ul&gt; computed: { filterlist () { // 拿到存在state.size的数组，意思是请求成功拿到的数据存到state // 要多行动态渲染的内容，直接绑定此方法 return处理好的数据 = 绑定一个数组 let num=this.size; return this.list.filter(function (number) { return number.id &lt; num }) } }, methods:{ filterTwo(val){ let num=this.size; return this.list.filter(function (number) { return number.id &lt; num }) }, addMore(){ this.size+=5; }, },]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios内部封装]]></title>
    <url>%2F2019%2F08%2F18%2Faxios%E5%86%85%E9%83%A8%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[#贴一下工作中用到的吧 目录结构： ├── service │ ├── index.js #用于统一定义接口地址，封装接口和使用封装好的请求方法 │ ├── baseService.js #调用config设置默认请求ip地址，响应器做超时处理，封装请求方法返回data └── config ├── index.js # 入口文件 ├── env.json # 更改要调用的角色的json文件 {&quot;dev&quot;: &quot;AAA&quot;} 改成BBB即调用BBB文件 ├── AAA.json # 角色A的ip └── BBB.json # 角色B的ip // 这里是用于多人开发时，对接不同后端接口的ip地址不同，后期会合并接口 最外层入口文件main.js，记得定义全局使用 Vue.prototype.$config = config Vue.prototype.$service = service 调用存放某人IP的JSON文件，暴露ip（作用是当开发时，多个后端的接口ip不同，修改调用哪个ip） // config index.js const env = require(&apos;./env.json&apos;).dev // 拿到AAA const config = require(&apos;./&apos; + env + &apos;.json&apos;) 拿到AAA.json const version = require(&apos;./version.json&apos;) //版本号，这里无用 config.version = version.version export default config // 暴露IP{&quot;apiUrl&quot;: &quot;http://0.0.0.0&quot;} 封装axios方法，配置请求地址为调用的默认ip + 后缀 // baseService.js import axios from &apos;axios&apos; import Config from &apos;#/config/index&apos; // 默认请求地址 axios.defaults.baseURL = Config.apiUrl // 超时时间 axios.defaults.timeout = 10000 // 错误拦截器 axios.interceptors.response.use( function (response) { return response }, function (error) { // 对响应错误做点什么 return Promise.reject(error) } ) function get (url, request) { //url为: 默认设置好的IP地址 + index文件传来的接口后缀，request为传参 return axios.get(url, { params: request }).then(response =&gt; { return response[&apos;data&apos;] // 这里是返回data数据：{sta:&quot;00&quot;,data:{...}} }) } function post (url, request) { return axios.post(url, request).then(response =&gt; { return response[&apos;data&apos;] }) } function put (url, request) { return axios.put(url, request).then(response =&gt; { return response[&apos;data&apos;] }) } function patch (url, request) { return axios.patch(url, request).then(response =&gt; { return response[&apos;data&apos;] }) } function del (url, request) { if (request) { url = url + getUrlQuery(request) } return axios.delete(url).then(response =&gt; { return response[&apos;data&apos;] }) } function getUrlQuery (request) { let result = &apos;?&apos; let isFirst = true for (const key in request) { if (isFirst) { isFirst = false result += key + &apos;=&apos; + request[key] } else { result += &apos;&amp;&apos; + key + &apos;=&apos; + request[key] } } return result } export default { get, post, put, del, patch } 统一封装接口，调用封装好的axios方法 // index.js import BaseService from &apos;./baseService.js&apos; function get (url, request) { return BaseService.get(url, request).then(response =&gt; { return response }) } function post (url, request) { return BaseService.post(url, request).then(response =&gt; { return response }) } function put (url, request) { return BaseService.put(url, request).then(response =&gt; { return response }) } function patch (url, request) { return BaseService.patch(url, request).then(response =&gt; { return response }) } function del (url, request) { return BaseService.del(url, request).then(response =&gt; { return response }) } /******************************/ function createService (url) { return { get: request =&gt; { return get(url, request) }, details: (id, request) =&gt; { return get(url + &apos;/&apos; + id, request) }, add: request =&gt; { return post(url, request) }, edit: (id, request) =&gt; { return put(url + &apos;/&apos; + id, request) }, del: id =&gt; { return del(url + &apos;/&apos; + id) } } } /******************************/ const User = createService(&apos;user&apos;) const login = request =&gt; { return post(&apos;login&apos;, request) } const logout= request =&gt; { return get(&apos;logout&apos;, request) } // 拼接url，调用时直接传：拼接值id、request请求参数 // 使用时，this.$封装的文件名.封装的接口名((id, {请求参数}).then(...) const del= (id, request) =&gt; { return del(&apos;del/&apos; + id, request) } ...... /******************************/ export default { User, login, logout, del } 贴一个网上的axios封装例子，可根据需求情况自行配置配置 jsVue.use(Vuex) Vue.use(VueAxios, axios) Vue.use(qs) 注：qs，使用axios，必须得安装 qs，所有的Post 请求，我们都需要 qs,对参数进行序列化。 在 request 拦截器实现 axios.interceptors.request.use( config =&gt; { config.baseURL = &apos;/api/&apos; config.withCredentials = true // 允许携带token ,这个是解决跨域产生的相关问题 config.timeout = 6000 let token = sessionStorage.getItem(&apos;access_token&apos;) let csrf = store.getters.csrf if (token) { config.headers = { &apos;access-token&apos;: token, &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; } } if (config.url === &apos;refresh&apos;) { config.headers = { &apos;refresh-token&apos;: sessionStorage.getItem(&apos;refresh_token&apos;), &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; } } return config }, error =&gt; { return Promise.reject(error) } ) //在 response 拦截器实现 axios.interceptors.response.use( response =&gt; { // 定时刷新access-token if (!response.data.value &amp;&amp; response.data.data.message === &apos;token invalid&apos;) { // 刷新token store.dispatch(&apos;refresh&apos;).then(response =&gt; { sessionStorage.setItem(&apos;access_token&apos;, response.data) }).catch(error =&gt; { throw new Error(&apos;token刷新&apos; + error) }) } return response }, error =&gt; { return Promise.reject(error) } )]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由守卫与token验证配置例子]]></title>
    <url>%2F2019%2F08%2F18%2F%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E4%B8%8Etoken%E9%AA%8C%E8%AF%81%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[路由守卫、登陆验证token、axios全局配置及拦截器和响应器初次使用遇到了，顺便把记一下吧，较简略 还未完善先丢一个官网路由守卫的使用示例 router.beforeEach((to, from, next) =&gt; { if (to.path === &apos;/login&apos;) { next() } else { // 登录验证 if (!store.state.isLogin) { // store状态设为true后，路由守卫放行 next(&apos;/login&apos;) } else { next() } } }) 这里的store.state.isLogin是放在全局状态里判断登录是否成功，默认false，如果登录成功后设置为true。(仅是一个例子，可根据自行爱好定义 登陆页面login.vue，post请求成功后commit触发定义在mutation的login方法，将返回的token和用户信息传过去，然后把token（和用户信息）存到缓存中 // sessionStorage用于临时保存在浏览器未关闭时 // 或用localStorage永久缓存，适用于（X天内自动登陆），记得设置过期时间 sessionStorage.setItem(&apos;user&apos;, this.form.username) store拿到数据后，保存token，设置全局axios请求头默认携带token，isLogin = true，转到首页 state.token = token axios.defaults.headers.common[&apos;Authorization&apos;] = token state.isLogin = true store.state初始时，先触发方法去查找本地缓存是否有用户信息 let data = sessionStorage.getItem(name) return data //注意存储的格式 //在状态管理里判断用户信息和token是否存在 if (sotreState &amp;&amp; sotreState.token) { sotreState.navbarActiveIndex = &apos;&apos; //初始化用在别处的状态 本例无用 sotreState.sidebarActiveIndex = &apos;&apos; //同上， axios.defaults.headers.common[&apos;Authorization&apos;] = sotreState.token //如果token存在，设置默认请求头携带token，初始状态 return sotreState } else { return initState() // 初始化store方法，全部清空 } 用户点击退出登陆时，触发logout方法，将store.state(和浏览器缓存)清空，跳回到登录页面 转一个网上的例子一 // http request 请求拦截器 // 作用是在发送请求前进行一些操作，例如在每个请求体里加上token axios.interceptors.request.use( config =&gt; { if (store.state.token) { // 判断是否存在token，如果存在的话，则每个http header都加上token config.headers.Authorization = `token ${store.state.token}`; } return config; }, err =&gt; { // 对响应错误做点什么 return Promise.reject(err); }); // http response 响应拦截器 // 作用是在接收到响应后进行一些操作，常用于统一配置错误状态提示，本例处理方法是将token信息清空 axios.interceptors.response.use( response =&gt; { return response; }, error =&gt; { if (error.response) { switch (error.response.status) { // 这里是后端返回错误码 case 401: // 返回 401 清除token信息并跳转到登录页面 store.commit(types.LOGOUT); // 派发清空状态(token)方法 router.replace({ path: &apos;login&apos;, query: {redirect: router.currentRoute.fullPath} }) } } return Promise.reject(error.response.data) // 返回接口返回的错误信息 }); 记一个处理思路 0.每次打开网页，store初始化时，可以定义方法setItem判断本地缓存里是否有token信息，和验证是否过期，如果存在则赋值给state.token，设置axios请求默认携带state.token，路由放行 第一次登录的时候，前端调后端的登陆接口，发送用户名和密码 后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token 前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面 前端每次跳转路由，就判断 localStroage（或在store设置Boolean值判断也行） 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面 每次调后端接口，都要在请求头中加token 后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401 如果前端拿到状态码为401，就清除token信息并跳转到登录页面]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于echarts的X轴显示不全]]></title>
    <url>%2F2019%2F08%2F18%2Ftitle%2F</url>
    <content type="text"><![CDATA[关于echarts的X轴显示不全xAxis: { axisLabel: { interval:0, // x轴文字间隔显示 rotate:40 // x轴文字 - 旋转角度 //formatter: function (val) { // return val.split(&apos;&apos;).join(&apos;\n&apos;) // X轴文字竖放，可自行定义处理格式 // } } }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记for in 和 for of 的详细区别]]></title>
    <url>%2F2019%2F08%2F12%2F%E8%AE%B0for-in-%E5%92%8C-for-of-%E7%9A%84%E8%AF%A6%E7%BB%86%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[for in 和 for of 详细区别首先，先放出两者对比概念 for…in 循环 for…in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。 for…in 语句用于对数组或者对象的属性进行循环操作。 for … in 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作。 for…in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。 for…of 循环 for … of循环是ES6引入的新的语法，用for … of循环遍历集合 for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。 这里直接记录下用法区分，用熟了概念也就掌握了 首先，for in 和 for of 都可用于数组[1,2,3] 或 对象{“a”: 1, “b”: 2, “c”: 3} 举个栗子，就能明白了 //这是 for in let data = {&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3} for (let key in data) { lemp[Number(key)] = rdata[key] console.log(key) // 这里的key为data数组的索引/键名 console.log(data[key]) // 打印 1,2,3 } // 注意 for in 循环可能会乱序，有顺序要求请用for遍历索引 // 注意 for in 会遍历所有可枚举属性，例如原型链上的方法和属性，可通过hasOwnProperty(key)判断：某属性是否为该对象的实例属性 // 注意 for in 遍历的索引为字符串型数字 // for in更适合遍历对象属性， 炒板栗 //这是for of let data1 = [1, 2, 3, 4] let data2 = [{&apos;name&apos;:张三, &apos;id&apos;: 01}, {&apos;name&apos;:李四, &apos;id&apos;: 02}] //下面循环偷懒写一次... for (let key of data) { console.log(key) // 循环data1时，打印 1,2,3,4 console.log(key.name) // 循环data2时，此处的key可看成是 data2[0],data2[1]，即打印 张三，李四 } // for of可遍历：数组/数组对象/字符串/map/set等都适用，但不能遍历对象{ },如要使用，可用Object.keys(data)循环属性，或Object.values(obj)循环属性值 // for of遍历的只是数组内的元素，而不包括原型 // for of更适合遍历数据，例如数组的值 补一个foreach循环 let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] arr.forEach(function (val, idx, arr) { console.log(val + &apos;, index = &apos; + idx) // val是当前元素，index当前元素索引，arr数组 console.log(arr) })]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下axios食用方法，以及工作中遇到的坑]]></title>
    <url>%2F2019%2F07%2F28%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Baxios%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[初上手axios真的被坑一脸血（摊上个不靠谱的同事有毒首先放一下axios的食用姿势 //这是get方法 axios.get(&apos;/user?ID=12345&apos;) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); //这是post方法 axios.post(&apos;/user&apos;, { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); //推荐统一用api方法 axios({ method: &apos;post&apos;, url: &apos;/user/12345&apos;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot; } data: { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; } }); 在使用GET方法传递参数时使用的是params，并且官方文档中介绍为：params are the URL parameters to be sent with the request. Must be a plain object or a URLSearchParams object。plain object（纯对象）是指用JSON形式定义的普通对象或者new Object()创建的简单对象；而URLSearchParams object指的是一个可以由URLSearchParams接口定义的一些实用方法来处理 URL 的查询字符串的对象，也就是说params传参是以/user?ID=1&amp;name=mike&amp;sex=male形式传递的(意思是get请求会以数据附加到URL地址后面的形式，一起传给后台 而在使用POST时对应的传参使用的是data，data是作为请求体发送的，同样使用这种形式的还有PUT，PATCH等请求方式。也就是说使用的是序列化后的json格式字符串来传递参数，如：{ “name” : “mike”, “sex” : “male” }；同时，后台必须要以支持@RequestBody的形式接收参数，否则会出现前台传参正确，后台接收不到的情况。 axios引入就不说了，这里在下项目用的是vue-axios 重点说一下，axios有三种常见的数据请求格式 Content-Type: application/json ： 请求体中的数据会以json字符串的形式发送到后端 Content-Type: application/x-www-form-urlencoded：请求体中的数据会以普通表单形式（键值对）发送到后端 Content-Type: multipart/form-data： 它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。 axios默认的请求头是第一种：Content-Type: application/json，并且在axios中会默认把数据序列化成JSON字符串格式。 对于第二种格式：application/x-www-form-urlencoded的传参 用 URLSearchParams API传递参数 let param = new URLSearchParams() param.append(&apos;username&apos;, &apos;admin&apos;) param.append(&apos;pwd&apos;, &apos;admin&apos;) axios({ method: &apos;post&apos;, url: &apos;/api, data: param }) 需要注意的是： URLSearchParams 不支持所有的浏览器，但是总体的支持情况还是 OK 的，所以优先推荐这种简单直接的解决方案 修改axios默认的请求头 axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 或者直接在api里更改 {headers:{&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;}} 之后引入qs库的Qs.stringify方法 import Qs from &apos;qs&apos; let data = { &quot;username&quot;: &quot;admin&quot;, &quot;pwd&quot;: &quot;admin&quot; } axios({ headers: { &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; }, method: &apos;post&apos;, url: &apos;/api/xxx&apos;, data: Qs.stringify(data) }) 修改axios源码中的transformRequest import Qs from &apos;qs&apos; axios({ url: &apos;/api/lockServer/search&apos;, method: &apos;post&apos;, transformRequest: [function (data) { // 对 data 进行任意转换处理 return Qs.stringify(data) }], headers: { &apos;deviceCode&apos;: &apos;A95ZEF1-47B5-AC90BF3&apos; }, data: { username: &apos;admin&apos;, pwd: &apos;admin&apos; } }) 手动连结 axios.post(&apos;/api/lockServer/search&apos;,&quot;userName=&apos;admin&apos;&amp;pwd=&apos;admin&apos;&quot;); 对于第三种格式：Content-Type: multipart/form-data的传参 对于这种类型的数据，我们常见前端页面上传个人图像，然后点击保存发送后端修改原始数据。 1234567891011121314151617let params = new FormData()params.append(&apos;file&apos;, this.file)params.append(&apos;id&apos;, localStorage.getItem(&apos;userID&apos;))params.append(&apos;userName&apos;, this.name)params.append(&apos;sex&apos;, this.sex)params.append(&apos;mobile&apos;, this.phone)params.append(&apos;email&apos;, this.email)params.append(&apos;qq&apos;, this.qq)params.append(&apos;weChat&apos;, this.WeChat)axios.post(URL, params, &#123;headers: &#123;&apos;Content-Type&apos;: &apos;multipart/form-data&apos;&#125;&#125;).then(res =&gt; &#123;if (res.data.code === 0) &#123;this.$router.go(-1)&#125;&#125;).catch(error =&gt; &#123;alert(&apos;更新用户数据失败&apos; + error)&#125;) 后记，错误500多半是服务器问题，打印下自己的数据格式，看跟接口要求的格式是否一样，然后就是后端的锅了。错误403是服务器拒绝访问，叫后端开接口，检查下自己URL有没输错。错误404，请求内容不存在。错误408，请求超时。301，重定向。200，返回正确结果即成功。这里推荐模拟请求接口的软件postman，拿到接口先测一遍（便于甩锅 另外，axios可以在全局配置请求头，请求格式，拦截器等，具体请参考官方文档，使用例子有登陆拦截配置token过期验证处理，把axios方法封装成自定义api……]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个十分简单的git教程网站]]></title>
    <url>%2F2019%2F06%2F03%2F%E4%B8%80%E4%B8%AA%E5%8D%81%E5%88%86%E7%AE%80%E5%8D%95%E7%9A%84git%E6%95%99%E7%A8%8B%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[分享链接:git - the simple guide支持中文，需翻墙]]></content>
  </entry>
  <entry>
    <title><![CDATA[记录一下vps的搭建过程]]></title>
    <url>%2F2019%2F06%2F02%2Fvps%2F</url>
    <content type="text"><![CDATA[首先，你得先有一台服务器例如抛瓦工、vultr之类的，自己去比较哪家性价比好点，想当梯子用的话必须买外国的服务器哦。怎么购买就不多说了，网上教程一大把，还支持支付宝/微信充值，这里仅记录一下成功搭建的过程。 首先购买到服务器之后，在控制台找到你服务器的IP，先去找个海外网速测速网站测试一下：测速网站 这里勾去外网只选国内，可以看到服务器ip与大陆各地区之间的延迟（如果通通超时的话，就是ip被ban了）ip被ban的话只能更换ip了，xshell连不上服务器同理。 服务器系统建议选centOS6 64或7 64，网上教程普遍为6，但cenntOS7好像也没问题。 选好服务器之后，在你本地电脑里下一个xshell用来连接服务器 新建 主机名填服务器ip 用户身份验证里，id普遍为root，密码填你服务器随机分配的密码 登陆成功后，控制台提示如图 五个流程搞定 第一步yum -y install wget 第二步安装中文版ssr1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 进去界面是中文的，非常简单！ 输入：1 安装ShadowsocksR，端口自行设置（建议1000以上），密码自定义，混淆插件选：plain,配置完之后会打印一段配置信息，记得copy保存。 如果忘记了，输入bash ssr.sh打开ssr主界面，选5看账号信息。 这里注意一个坑，如果你ssr和bbr都配置好了，但就是连不上网且ping不通，打开ssr选7重新设置端口！有时候连不上是端口的问题。 第三步安装加速 这里有原版Google bbr、魔改版bbr、锐速、等加速算法选择，如果不设置加速，网速会非常慢！而且加速之间也有区别，如果搭配完发现网速太慢，可尝试换一种加速算法，具体教程网上基本都有，这里在下用的是魔改bbr。 安装魔改版bbr 1wget --no-check-certificate https://raw.githubusercontent.com/nanqinlang-tcp/tcp_nanqinlang/master/General/CentOS/bash/tcp_nanqinlang-1.3.2.sh &amp;&amp; bash tcp_nanqinlang-1.3.2.sh 先输入1安装内核，安装完成后输入reboot重启服务器 等待几分钟后，运行脚本1bash tcp_nanqinlang-1.3.2.sh 选择2开启算法 安装成功后会提示两句话 1tcp_nanqinlang is installed ! 1tcp_nanqinlang is running ! 至此，梯子已经搭建完成。简单吧？ 搜索ssr客户端下载，填写配置信息后就能去查阅墙外的文献啦，这里就不贴下载链接了。 友情贴一个外网的测速地址戳这里，还可以去试试访问Facebook，twitter,和youtube观看测试1080p视频的网速情况哦。 ###谢谢观看]]></content>
      <categories>
        <category>网络知识</category>
      </categories>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人在hexo遇到的坑]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%B8%AA%E4%BA%BA%E5%9C%A8hexo%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[###1.下载百度提交链接模块遇到bug 整百度SEO的时候，有个向百度提交自己网站地址的操作，安装了 “hexo-baidu-url-submit –save” 这个插件，网站认证是通过了. 然而，我吃个晚饭回来准备继续整网站时, hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 一堆报错提示！当时内心简直崩溃！！！(才不会说是未保存就在本地调主题呢… 这个bug我也没整懂，翻译意思好像是”Count”未赋值，一堆js文件里提示error:”Count”undefined，简直抓狂啊，这要怎么找bug！ copy关键句怎样百度都没办法，甚至想到了克隆之前提交能跑的git仓库（结果没有克隆blog上传，git仓库里的是整合好的…)发现git仓库最近一次提交是19：22，于是只能用蠢办法翻chrome历史纪录查自己弄过什么插件了，照着历史纪录一个一个插件uninstall回去，改过的配置一一还原，最终通过报错的js文件，找到了源头”百度提交插件”的锅… npm uninstall hexo-baidu-url-submit –save ，得嘞 你给我滚回去吧(怒 ###2.fs.SyncWriteStream is deprecated 关于这个错误，参考了这篇博主的文章：https://www.leiyawu.com/2018/02/28/hexo-fs-SyncWriteStream-is-deprecated/ 这里稍微贴下方法步骤吧 npm install hexo-fs –save&emsp;更新hexo-fs插件 问题出在：hexo-admin的hexo-fs因hexo-admin作为后台管理，无法npm uninstall hexo-admin卸载,则找到对应文件，注释： [root@server init]# grep -irn “SyncWriteStream” ./node_modules/hexo-admin/./node_modules/hexo-admin/node_modules/hexo-fs/lib/fs.js:718:exports.SyncWriteStream = fs.SyncWriteStream;[root@lywserver init]# 将对应的exports.SyncWriteStream = fs.SyncWriteStream;注释(前面 //)即可！ ###3.蠢蠢的把网站下面运行时间的©打成了@,这个报错很好就找到了…]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
